\section{Community Detection}

\subsection{The Communication Graph}

Many previous and current popularity metrics for Twitter focus on the followers graph.  Indeed, twitterers create a datastream, similar to RSS news, by subscribing to -- or following -- other twitterers.  However, as pointed out by Finin et al. \cite{DBLP:conf/kdd/JavaSFT07}, the number of followers doesn't necessarily predict influence or social bonds.  What matters are actions -- and in case of Twitter, direct communications, called replies.

Anybody can address anybody else publicly, by simply inserting the addresseeâ€™s nickname, preceded with @, into the twit (then called reply).  We can extract replies from all twits and build a communication graph out of them.  Such a graph can be static, being a snapshot at a certain time, or dynamic, where nodes and edges are added with timestamps, constituting a multigraph.  When looking for communities, we propose to do so through the communication graph, revealing those engaged with each other, presumably over a set of topics.

Our exploration workflow, outlined in Figure~\ref{figure:workflow}, begins with a search phrase, such as ``Glenn Beck.''  We then identify pairs of repliers from the communication multigraph who exchange this phrase in both directions, and sort the pairs by the number of total exchanges they had.  The top pair would be the most active, and becomes our seed candidate for the community.  We grow the community from that seed pair as follows.

\subsection{Growing a Community}

Our community identification algorithms is indirectly inspired by Backstrom and Kleinberg \cite{DBLP:conf/kdd/BackstromHKL06}, who made the following observation when studying the dynamics of the community growth.  A new member is much likelier to join a community when he has two friends already in the community, not yet connected themselves (an open triad).  We simplify it by not insisting the two friends have no links, but requiring that a prospective member has at least two friends already in the community.

Hence, the algorithm proceeds as follows.  We start (*) with a pair, $(A,B)$, in a queue, who are the seed members of the community.  They may or may not have a link -- e.g., in one version, we actually find such pairs which exchanged messages with a topic, such as ``Glenn Beck,'' in them, while in another, we seed with two unconnected users, independently interested in the topic.  (An option may further control whether there should be messages in each direction, signifying mutual interest, i.e. at least two, or one will suffice.)  After that, we sort friends of $A$ in the decreasing order of the total number of messages exchanged, do the same with $B$'s friends, and then find the first shared friend in the list, $C$.  $C$ is then added to the community, and the pairs $(A,C), (B,C)$ are added to the queue.  The process (*) is then repeated until the queue is exhausted.

There are certain asymmetries in the communities grown by the versions of this algorithm where only one direction of the edges are required.  If we allow for a single directed edge as a (topical) relationship marker, we will get different communities when starting with the pair $(A,B)$ rather than $(B,A)$.  Such differences can be considered as a result of the bias towards $A$ or $B$, or compensated for by requiring edges in both directions.  Here we ensure symmetry by requiring both edges.

In our studies with several seeding topics, the communities saturate fairly quickly, conforming to the idea of a tightly knit cluster \cite{DBLP:conf/waw/MishraSST07} being characteristic for a community.  Figure~\ref{figure:workflow} contains an example where the seeding pair, Alice and Bob, both talk to a third user, Pat, the most, hence bringing her into the community.  The process is repeated until no new triangles exist, or until a set limit is reached.  Two kinds of limits can be set: by the total size of the community, or the distance, in generations, from the seeding pair.  The generations are natural layers, and computed as follows.  The seeding pair members both are generation 0.  In a triangle, the new member gets the lowest parent generation plus 1.  The process can be stopped when a given layer is reached.

\subsection{Fringe}

The fringe of a community is a set of users connected, in the communication graph, to at least one member of the community, but which themselves are not its members.  Once the fringe is detected, its twit set can be examined for SIPs.  Those can provide a set of choices for further exploration, to restart the community building process.  We outline such a process as a basis of data exploration below.

\subsection{Pruning a Community}
Community graphs are build from a set of directed edges -- $E(from,to,weight)$ -- where weight is the number of messages which traversed that edge in the dataset.  Since the time sample was so long, there is an not insignificant number of edges with low weights.  Such low weighted edges represent transient communications between users and more closely resemble noise than structural components of the communities.

In order then to create meaningful community structures, the edge set $E$ must be trimmed of edges with low weight which can, if further analysis is performed, obscure the tightly knit central clusters we hope to find.  For the data sets used for this paper, we chose a cutoff weight based on the obvious threshold in the histogram of the weights on the graph, usually a number of twits between 1 and 5.